streamlit>=1.26.0
from xgboost import XGBClassifier
from sklearn.ensemble import RandomForestClassifier

class ModelTrainer:
    def __init__(self, x_train, y_train):
        self.x_train = x_train
        self.y_train = y_train
        self.rf_model = RandomForestClassifier(random_state=42, criterion='gini', max_depth=4, n_estimators=100)
        self.xgb_model = XGBClassifier(random_state=42, n_estimators=100, min_child_weight=50, max_depth=8)

    def train_rf(self):
        self.rf_model.fit(self.x_train, self.y_train)
        return self.rf_model

    def train_xgb(self):
        self.xgb_model.fit(self.x_train, self.y_train)
        return self.xgb_model

import pandas as pd
from sklearn.preprocessing import OneHotEncoder, RobustScaler
import pickle

class DataPreprocessor:
    def __init__(self, df):
        self.df = df
        self.x = self.df[self.df.columns.drop(['loan_status'])]
        self.y = self.df['loan_status']
    
    def handle_missing_values(self):
        self.x['person_income'].fillna(self.x['person_income'].median(), inplace=True)
    
    def handle_categorical_data(self):
        self.x['person_gender'] = self.x['person_gender'].str.lower().str.replace(" ", "").replace({"fe male": "female"})
        self.x['loan_intent'] = self.x['loan_intent'].replace({'DEBTCONSOLIDATION': 'DEBT CONSOLIDATION', 'HOMEIMPROVEMENT': 'HOME IMPROVEMENT'})
        self.x['person_gender'] = self.x['person_gender'].map({'Male': 1, 'Female': 0})
        self.x['previous_loan_defaults_on_file'] = self.x['previous_loan_defaults_on_file'].map({'Yes': 1, 'No': 0})
    
    def encode_education(self):
        person_education_encoder = {"High School": 0, "Associate": 1, "Bachelor": 2, "Master": 3, "Doctorate": 4}
        self.x = self.x.replace({"person_education": person_education_encoder})
    
    def one_hot_encode(self):
        home_ownership_encoder = OneHotEncoder()
        loan_intent_encoder = OneHotEncoder()
        person_home_ownership_train = pd.DataFrame(home_ownership_encoder.fit_transform(self.x[['person_home_ownership']]).toarray(), 
                                                  columns=home_ownership_encoder.get_feature_names_out())
        loan_intent_train = pd.DataFrame(loan_intent_encoder.fit_transform(self.x[['loan_intent']]).toarray(), 
                                        columns=loan_intent_encoder.get_feature_names_out())
        self.x = pd.concat([self.x, person_home_ownership_train, loan_intent_train], axis=1)
        self.x = self.x.drop(['person_home_ownership', 'loan_intent'], axis=1)
        
    def scale_data(self):
        numerical = self.x.select_dtypes(include=['number']).columns.tolist()
        scaler = RobustScaler()
        for col in numerical:
            self.x[[col]] = scaler.fit_transform(self.x[[col]])
            pickle.dump(scaler, open(f"{col}_scaler.pkl", "wb"))
        
    def preprocess(self):
        self.handle_missing_values()
        self.handle_categorical_data()
        self.encode_education()
        self.one_hot_encode()
        self.scale_data()
import pickle

class ModelSaver:
    def __init__(self):
        pass
    
    def save_model(self, model, filename):
        pickle.dump(model, open(filename, "wb"))
        
    def save_encoder(self, encoder, filename):
        pickle.dump(encoder, open(filename, "wb"))
import pickle

class Encoders:
    @staticmethod
    def encode_gender(value):
        gender_encoder = pickle.load(open("gender_encode.pkl", "rb"))
        return gender_encoder.get(value, 0)  # default to 0 if not found
    
    @staticmethod
    def encode_previous_loan(value):
        previous_loan_encoder = pickle.load(open("previous_loan_encode.pkl", "rb"))
        return previous_loan_encoder.get(value, 0)
    
    @staticmethod
    def encode_education(value):
        person_education_encoder = pickle.load(open("person_education_encode.pkl", "rb"))
        return person_education_encoder.get(value, 0)
    
    @staticmethod
    def encode_loan_intent(value):
        loan_intent_encoder = pickle.load(open("loan_intent_encode.pkl", "rb"))
        return loan_intent_encoder.transform([[value]]).toarray()
import pickle

class Scalers:
    @staticmethod
    def scale_feature(col_name, value):
        scaler = pickle.load(open(f"{col_name}_scaler.pkl", "rb"))
        return scaler.transform([[value]])
